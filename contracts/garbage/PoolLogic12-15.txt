//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IERC20Metadata} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";

import {PoolStorage} from '../pool/PoolStorage.sol';
import {ICollateralToken} from '../tokens/ICollateralToken.sol';
import {IAvaToken} from '../tokens/IAvaToken.sol';
import {IDebtToken} from '../tokens/IDebtToken.sol';

import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import {WadRayMath} from './WadRayMath.sol';
import {IBridge} from '../anchor/IBridge.sol';
import {IPriceConsumerV3} from '../oracles/IPriceConsumerV3.sol';

import "hardhat/console.sol";

// actual
library PoolLogic {
    using SafeMath for uint256;
    using WadRayMath for uint256;

    uint256 constant ONE_YR = 31536000;
    uint256 constant ONE_FACTOR = 1e18;

    function initCollateralToken(
        PoolStorage.PoolAsset storage collateralAsset,
        address asset,
        address collateralAssetWrapped,
        address bridgeAddress,
        /* address bridgeExchangeRateFeederAddress, */
        uint256 bridgeMinSupplyRedeemAmount,
        uint256 bridgeMaxSupplyRedeemAmount,
        uint256 collateralInterestRateFactor,
        uint256 ltv
    ) external {
        (
          uint256 bridgeExchangeRate,
          uint256 bridgeInterestRate
        ) = _getInterestData(bridgeAddress);

        collateralAsset.asset = asset; // ust
        collateralAsset.decimals = IERC20Metadata(asset).decimals();
        collateralAsset.collateralExchangeRate = 1e18;
        collateralAsset.collateralInterestRateFactor = collateralInterestRateFactor;
        collateralAsset.collateralAssetWrapped = collateralAssetWrapped;
        collateralAsset.bridgeAddress = bridgeAddress; //address to router to send collateral to anchor
        /* collateralAsset.bridgeExchangeRateFeederAddress = bridgeExchangeRateFeederAddress; */
        collateralAsset.bridgeExchangeRate = bridgeExchangeRate; // storeed byways of anchor exchangeRateFeeder
        collateralAsset.bridgeInterestRate = bridgeInterestRate; // eestimated by exchangeRateFeeder
        collateralAsset.bridgeMinSupplyRedeemAmount = bridgeMinSupplyRedeemAmount*(10**collateralAsset.decimals); // min amount bridge allows
        collateralAsset.bridgeMaxSupplyRedeemAmount = bridgeMaxSupplyRedeemAmount*(10**collateralAsset.decimals);
        collateralAsset.isCollateral = true;
        collateralAsset.isSavings = false; // collateral is always called first if there is, will update to true if we init savings and debt asset
        collateralAsset.on = true;
        collateralAsset.reserveFactor = uint256(100000000000000000); // 10%
        collateralAsset.maxCollateralBonusFactor = uint256(50000000000000000); // 5%


        // may need to update this on each call
        /* collateralAsset.liquidationThreshold = uint256(1e18).wadMul(uint256(1e18)).add((bridgeInterestRate.wadMul(collateralInterestRateFactor)).div(ONE_YR)).wadPow(loanThresholdSeconds); // works bot may not be accurate
        console.log("collateralAsset.liquidationThreshold", collateralAsset.liquidationThreshold); */

        collateralAsset.ltv = ltv;
        /* collateralAsset.loanThresholdSeconds = loanThresholdSeconds; */
        collateralAsset.liquidationBonusFactor = uint256(100000000000000000); // 10%


    }

    function initcToken(
        PoolStorage.PoolAsset storage poolAsset,
        address asset,
        address wrapped,
        address bridgeAddress,
        uint256 bridgeMinSupplyRedeemAmount,
        uint256 depositsSuppliedInterestRateFactor
    ) internal {
        (
          uint256 bridgeExchangeRate,
          uint256 bridgeInterestRate
        ) = _getInterestData(bridgeAddress);

        poolAsset.isSavings = true;

        poolAsset.asset = asset;
        poolAsset.decimals = IERC20Metadata(asset).decimals();
        poolAsset.wrapped = wrapped;

        poolAsset.reserveFactor = uint256(100000000000000000); // 10%

        poolAsset.depositsSuppliedExchangeRate = uint256(1e18);
        poolAsset.overallExchangeRate = uint256(1e18);
        poolAsset.depositsSuppliedInterestRateFactor = depositsSuppliedInterestRateFactor;
        poolAsset.depositsSuppliedInterestRate = bridgeInterestRate.wadMul(depositsSuppliedInterestRateFactor);

        poolAsset.lendableExchangeRate = uint256(1e18);
        // debt asset

        poolAsset.bridgeAddress = bridgeAddress; //address to router to send collateral to anchor
        poolAsset.bridgeExchangeRate = bridgeExchangeRate; // storeed byways of anchor exchangeRateFeeder
        poolAsset.bridgeInterestRate = bridgeInterestRate; // eestimated by exchangeRateFeeder

        /* poolAsset.bridgeMaxSupplyAllottedFactor = bridgeMaxSupplyAllottedFactor; // max protocol allotted to bridge */
        poolAsset.bridgeMinSupplyRedeemAmount = bridgeMinSupplyRedeemAmount*(10**poolAsset.decimals); // min amount bridge allows
        /* poolAsset.bridgeMaxSupplyRedeemAmount = bridgeMaxSupplyRedeemAmount; */

        poolAsset.lastUpdatedTimestamp = block.timestamp;

        poolAsset.on = true;
    }

    function initDebtToken(
        PoolStorage.PoolAsset storage poolAsset,
        address debtWrappedAsset,
        uint256 debtInterestRateFactor,
        uint256 loanThresholdSeconds
    ) internal {
        (
          ,
          uint256 bridgeInterestRate
        ) = _getInterestData(poolAsset.bridgeAddress);

        uint256 borrowInterestRate = bridgeInterestRate.wadMul(debtInterestRateFactor);
        poolAsset.borrowInterestRate = borrowInterestRate;
        poolAsset.debtWrappedAsset = debtWrappedAsset; // wrapped asset representing
        poolAsset.debtInterestRateFactor = debtInterestRateFactor; // percentage of interest rate of collateral rate to be the borrow rate --- 20% (borrow rate) * 50% = 10%
        poolAsset.borrowInterestRate = bridgeInterestRate.wadMul(debtInterestRateFactor);
        poolAsset.borrowExchangeRate = uint256(1e18);
        poolAsset.liquidationThreshold = uint256(1e18).wadMul(uint256(1e18)).add((poolAsset.borrowInterestRate).div(ONE_YR)).wadPow(loanThresholdSeconds); // works bot may not be accurate
        poolAsset.maxDebtRepayFactor = uint256(500000000000000000); // 50%

        poolAsset.minDebtTimeframe = uint256(5259486); // 2 months
        poolAsset.maxDebtTimeframe = uint256(7257600); // 3 months
        poolAsset.fullLiquidationTimeframe = uint256(14515200); // 4 months

        /* poolAsset.liquidationThreshold = uint256(1e18).wadMul(uint256(1e18)).add(bridgeInterestRate.div(ONE_YR)).wadPow(loanThresholdSeconds); // works bot may not be accurate
        poolAsset.ltv = ltv;
        poolAsset.loanThresholdSeconds = loanThresholdSeconds;
        poolAsset.liquidationBonusFactor = uint256(100000000000000000); // 10% */

    }

    function _getInterestData(address bridge) public view returns (uint256, uint256) {
        (
            uint256 interestRate,
            uint256 exchangeRate
        ) = IBridge(bridge).getInterestData();
        return (exchangeRate, interestRate);
    }

    function accrueInterest(
        PoolStorage.PoolAsset storage poolAsset
    ) internal {

        /* if (poolAsset.lastUpdatedTimestamp >= block.timestamp) {
            return;
        } */

        (
          uint256 bridgeExchangeRate,
          uint256 bridgeInterestRate
        ) = _getInterestData(poolAsset.bridgeAddress);

        // may need to manually do exchange rate on borrows in case simulate isn't updated enough
        if (poolAsset.bridgeExchangeRate >= bridgeExchangeRate) {
            poolAsset.lastUpdatedTimestamp = block.timestamp;
            return;
        }

        uint256 bridgeExchangeRateAccrued = bridgeExchangeRate.sub(poolAsset.bridgeExchangeRate);
        uint256 rateAccrued = bridgeExchangeRateAccrued.wadDiv(poolAsset.bridgeExchangeRate);

        if (poolAsset.isCollateral) {
            accrueCollateral(
                poolAsset,
                rateAccrued
            );
        }

        if (poolAsset.isSavings) {
            // update debt | borrow
            uint256 debtScaledSupply = IDebtToken(poolAsset.debtWrappedAsset).totalScaledSupply();

            // lended to borrowers
            uint256 lendableAccrued;
            // get b4 update
            uint256 lastUpdatedLendableTotalSupply = poolAsset.totalDepositsLendable;

            // bridged supply
            /* uint256 bridgeSupplyAccrued; */
            /* uint256 lastUpdatedBridgeTotalSupply; */

            if (debtScaledSupply != 0) {
                uint256 lastUpdatedDebtTotalSupply = debtScaledSupply.wadMul(poolAsset.borrowExchangeRate);

                (
                    uint256 borrowExchangeRate
                ) = accrueDebt(
                    poolAsset,
                    rateAccrued
                );

                uint256 updatedDebtTotalSupply = debtScaledSupply.wadMul(poolAsset.borrowExchangeRate);

                uint256 debtAccrued = updatedDebtTotalSupply.sub(lastUpdatedDebtTotalSupply);

                // deposits
                // can lendable supply just use the borrow index?
                // it can't because bridging may fail and need to rebalance
                // lended out to borrowers
                // update lending amounts
                // lending is done by principal andd not index



                (
                    uint256 updatedLendableTotalSupply
                ) = accrueLendableSupply(
                    poolAsset,
                    debtAccrued
                );
                lendableAccrued = updatedLendableTotalSupply.sub(poolAsset.totalDepositsLendable);

            }

            // get bridged assets
            uint256 bridgeTotalScaledSupply = IAvaToken(poolAsset.wrapped).depositsSuppliedTotalScaledSupply();
            uint256 lastUpdatedBridgeTotalSupply = bridgeTotalScaledSupply.wadMul(poolAsset.depositsSuppliedExchangeRate);
            /* console.log("bridge accrue lastUpdatedBridgeTotalSupply", lastUpdatedBridgeTotalSupply); */


            (
                uint256 depositsSuppliedExchangeRate
            ) = accrueDepositsSupplied(
                poolAsset,
                rateAccrued
            );

            /* console.log("accrue poolAsset.depositsSuppliedExchangeRate", poolAsset.depositsSuppliedExchangeRate); */

            uint256 updatedBridgeTotalSupply = bridgeTotalScaledSupply.wadMul(depositsSuppliedExchangeRate);
            /* console.log("bridge accrue updatedBridgeTotalSupply",  updatedBridgeTotalSupply); */
            uint256 bridgeSupplyAccrued = updatedBridgeTotalSupply.sub(lastUpdatedBridgeTotalSupply);

            // est anchor exchange ratte

            // anchor
            // get last updated totalSupply of anchor asset Which is principal+interest
            // get updated totalSupply of anchor asset Which is principal+interest
            // update variable
            /* console.log("accrue amount accrued", lendableAccrued.add(bridgeSupplyAccrued)); */
            /* console.log("accrue last updated supply", lastUpdatedBridgeTotalSupply.add(lastUpdatedLendableTotalSupply)); */

            accrueOverallDepositExchangeRate(
                poolAsset,
                lendableAccrued.add(bridgeSupplyAccrued), // aDAI appreciation | amount from anchor since last update
                lastUpdatedBridgeTotalSupply.add(lastUpdatedLendableTotalSupply) // previous totalSupply overall
            );
        }

        // update
        poolAsset.lastUpdatedTimestamp = block.timestamp;
        poolAsset.bridgeExchangeRate = bridgeExchangeRate;
        poolAsset.bridgeInterestRate = bridgeInterestRate;
    }


    function accrueDepositsSupplied(
        PoolStorage.PoolAsset storage poolAsset,
        uint256 rateAccrued
    ) internal returns (uint256) {
        uint256 supplyBridgeRateAccrued = rateAccrued.wadMul(poolAsset.depositsSuppliedInterestRateFactor); // accrud/last*depositsSuppliedInterestRateFactor
        // accrud/last*depositsSuppliedInterestRateFactor*reserveeFactor
        poolAsset.depositsSuppliedExchangeRate = poolAsset.depositsSuppliedExchangeRate.add(poolAsset.depositsSuppliedExchangeRate.wadMul(supplyBridgeRateAccrued));
        return poolAsset.depositsSuppliedExchangeRate;
    }
    // =========================================================
    // collateral

    function accrueCollateral(
        PoolStorage.PoolAsset storage collateralAsset,
        uint256 rateAccrued
    ) internal {
        uint256 collateralTotalScaledSupply = ICollateralToken(collateralAsset.collateralAssetWrapped).totalScaledSupply();
        uint256 previousCollateralTotalSupply = collateralTotalScaledSupply.wadMul(collateralAsset.collateralExchangeRate);

        uint256 collateralPremium = rateAccrued.wadMul(collateralAsset.collateralInterestRateFactor);
        // get amount with exchangerate without facctoring reserve factor
        uint256 updatedCollateralTotalSupply = collateralTotalScaledSupply.wadMul(
                collateralAsset.collateralExchangeRate.add(collateralAsset.collateralExchangeRate.wadMul(collateralPremium)
            )
        );


        uint256 collateralAccruedRate = collateralPremium.wadMul(ONE_FACTOR.sub(collateralAsset.reserveFactor));
        collateralAsset.collateralExchangeRate = collateralAsset.collateralExchangeRate.add(collateralAsset.collateralExchangeRate.wadMul(collateralAccruedRate));

        ICollateralToken(collateralAsset.collateralAssetWrapped).mintToReserve((updatedCollateralTotalSupply.sub(previousCollateralTotalSupply)).wadMul(collateralAsset.reserveFactor), collateralAsset.collateralExchangeRate);
    }
    // =========================================================

    // =========================================================
    // lendable supply
    function accrueLendableSupply(
        PoolStorage.PoolAsset storage poolAsset,
        uint256 debtAccrued
    ) internal returns (uint256) {
        uint256 lastLendableTotalSupply = IAvaToken(poolAsset.wrapped).lendableTotalSupplyPrincipal(); // total amount loaned or free to lend
        /* uint256 totalDepositsLendable = lastLendableTotalSupply.add(debtAccrued.wadMul(poolAsset.reserveFactor)); // last updatedd lend + borrower repayments (and suedo repayments) */
        uint256 totalDepositsLendable = lastLendableTotalSupply.add(debtAccrued); // last updatedd lend + borrower repayments (and suedo repayments)
        poolAsset.totalDepositsLendable = totalDepositsLendable;
        return totalDepositsLendable;
    }

    // =========================================================
    // debt
    function accrueDebt(
        PoolStorage.PoolAsset storage poolAsset,
        uint256 bridgeExchangeRateAccrued
    ) internal returns (uint256) {
        uint256 lastBorrowExchangeRate = poolAsset.borrowExchangeRate;
        uint256 rateAccrued = bridgeExchangeRateAccrued.wadMul(poolAsset.debtInterestRateFactor); // accrud/last*debtInterestRateFactor
        /* uint256 rateAccrued = bridgeExchangeRateAccrued.wadMul(poolAsset.debtInterestRateFactor).wadMul(poolAsset.reserveFactor); // accrud/last*debtInterestRateFactor */
        poolAsset.borrowExchangeRate = lastBorrowExchangeRate.add(lastBorrowExchangeRate.wadMul(rateAccrued));
        return poolAsset.borrowExchangeRate;
    }

    function simulateBorrowExchangeRate(
        uint256 bridgeExchangeRate, // latest updated
        uint256 lastUpdatedBridgeExchangeRate,
        uint256 debtInterestRateFactor,
        uint256 lastUpdatedBorrowExchangeRate
    ) external view returns (uint256) {

        if (lastUpdatedBridgeExchangeRate >= bridgeExchangeRate) { return lastUpdatedBorrowExchangeRate; }

        // amount accrued since last update
        uint256 bridgeExchangeRateAccrued = bridgeExchangeRate.sub(lastUpdatedBridgeExchangeRate);

        uint256 rateAccrued = (bridgeExchangeRateAccrued.wadDiv(lastUpdatedBridgeExchangeRate)).wadMul(debtInterestRateFactor); // accrud/last*debtInterestRateFactor

        return lastUpdatedBorrowExchangeRate.add(lastUpdatedBorrowExchangeRate.wadMul(rateAccrued));
    }


    struct simulateOverallExchangeRateParams {
        uint256 overallExchangeRate;
        uint256 totalDepositsLendable;
        uint256 debtScaledSupply;
        uint256 lastUpdatedDepositBridgeTotalSupply;
        address wrapped;
        address debtWrappedAsset;
    }

    function simulateOverallExchangeRate(
        uint256 overallExchangeRate, // poolAsset.overallExchangeRate
        uint256 bridgeExchangeRate,
        uint256 lastUpdatedBridgeExchangeRate, // poolAsset.bridgeExchangeRate,
        bool isSavings, //poolAsset.isSavings,
        address debtWrappedAsset,// poolAsset.debtWrappedAsset,
        uint256 totalDepositsLendable, // poolAsset.totalDepositsLendable,
        uint256 lastUpdatedBorrowExchangeRate, // poolAsset.borrowExchangeRate,
        uint256 updatedBorrowExchangeRate,
        uint256 lastUpdatedDepositSuppliedExchangeRate,
        uint256 updatedDepositsSuppliedExchangRate,
        address wrapped, // poolAsset.wrapped
        uint256 reserveFactor // poolAsset.reserveFactor
    ) external view returns (uint256) {
        simulateOverallExchangeRateParams memory params;
        params.overallExchangeRate = overallExchangeRate;
        params.totalDepositsLendable = totalDepositsLendable;
        params.wrapped = wrapped;
        params.debtWrappedAsset = debtWrappedAsset;

        if (lastUpdatedBridgeExchangeRate >= bridgeExchangeRate) {
            return params.overallExchangeRate;
        }

        if (isSavings) {

            // update debt | borrow
            params.debtScaledSupply = IDebtToken(params.debtWrappedAsset).totalScaledSupply();

            uint256 lendableAccrued;

            if (params.debtScaledSupply != 0) {
                uint256 lastUpdatedDebtTotalSupply = params.debtScaledSupply.wadMul(lastUpdatedBorrowExchangeRate);
                uint256 lendableAccrued = params.debtScaledSupply.wadMul(updatedBorrowExchangeRate).sub(lastUpdatedDebtTotalSupply);
            }
            // get bridged assets
            params.lastUpdatedDepositBridgeTotalSupply = IAvaToken(params.wrapped).depositsSuppliedTotalScaledSupply().wadMul(lastUpdatedDepositSuppliedExchangeRate);

            uint256 depositBridgeAccrued = IAvaToken(params.wrapped).depositsSuppliedTotalScaledSupply().wadMul(updatedDepositsSuppliedExchangRate).sub(params.lastUpdatedDepositBridgeTotalSupply);

            return accrueOverallDepositExchangeRateSimulated(
                params.overallExchangeRate,
                lendableAccrued.add(depositBridgeAccrued), // aDAI appreciation | amount from anchor since last update
                params.lastUpdatedDepositBridgeTotalSupply.add(params.totalDepositsLendable), // previous totalSupply overall
                reserveFactor
            );
        }
    }

    function accrueOverallDepositExchangeRateSimulated(
        uint256 overallExchangeRate,
        uint256 totalRepay,
        uint256 previousTotalSupply,
        uint256 reserveFactor
    ) internal view returns (uint256) {
        if (totalRepay <= 0) {
            return overallExchangeRate;
        }
        return overallExchangeRate.add((overallExchangeRate.wadMul((totalRepay.wadMul(ONE_FACTOR.sub(reserveFactor))).wadDiv(previousTotalSupply))));
    }


    function simulateCollateralExchangeRate(
        uint256 bridgeExchangeRate,
        uint256 lastUpdatedBridgeExchangeRate,
        uint256 lastUpdatedCollateralExchangeRate,
        uint256 collateralInterestRateFactor,
        uint256 reserveFactor
    ) external view returns (uint256) {

        /* uint256 lastCollateralExchangeRate = lastUpdatedCollateralExchangeRate; */

        if (lastUpdatedBridgeExchangeRate >= bridgeExchangeRate) { return lastUpdatedCollateralExchangeRate; }
        uint256 bridgeExchangeRateAccrued = (bridgeExchangeRate.sub(lastUpdatedBridgeExchangeRate)).wadDiv(lastUpdatedBridgeExchangeRate);
        uint256 rateAccrued = bridgeExchangeRateAccrued.wadMul(collateralInterestRateFactor).wadMul(ONE_FACTOR.sub(reserveFactor)); // accrud/last*debtInterestRateFactor
        uint256 updatedCollateralExchangeRate = lastUpdatedCollateralExchangeRate.add(lastUpdatedCollateralExchangeRate.wadMul(rateAccrued));
        return updatedCollateralExchangeRate;
    }


    // =========================================================
    // deposit savings

    function simulateLendableTotalSupply(
        address debtWrappedAsset,
        uint256 updatedBorrowExchangeRate,
        uint256 totalDepositsLendable,
        uint256 bridgeExchangeRate,
        uint256 lastUpdatedBridgeExchangeRate,
        uint256 lastUpdatedBorrowExchangeRate
    ) external view returns (uint256) {
        if (bridgeExchangeRate <= lastUpdatedBridgeExchangeRate) { return totalDepositsLendable; }
        uint256 debtTotalScaledSupply = IDebtToken(debtWrappedAsset).totalScaledSupply();
        uint256 lastUpdatedDebtTotalSupply = debtTotalScaledSupply.wadMul(lastUpdatedBorrowExchangeRate);
        uint256 debtTotalSupply = debtTotalScaledSupply.wadMul(updatedBorrowExchangeRate);
        uint256 debtTotalSupplyAccrued = debtTotalSupply.sub(lastUpdatedDebtTotalSupply);
        /* uint256 totalDepositsLendable = totalDepositsLendable.add(debtTotalSupplyAccrued);
        return totalDepositsLendable; */
        return totalDepositsLendable.add(debtTotalSupplyAccrued);
    }

    // =========================================================

    /* function rebalance(
        PoolStorage.PoolAsset storage poolAsset
    ) internal returns (uint256, uint256){
        uint256 amountToSupplyToBridgeToAchieveMatch = rebalanceBridgeRealTime(
            poolAsset
        );

        // total amount already supplied including interest gained
        uint256 bridgeTotalSupply = IAvaToken(poolAsset.wrapped).bridgeTotalSupply();

        uint256 bridgeMinSupplyRedeemAmount = poolAsset.bridgeMinSupplyRedeemAmount;
        uint256 amountToSupply;
        bool supplyAsset;
        if (amountToSupplyToBridgeToAchieveMatch >= bridgeTotalSupply.add(bridgeMinSupplyRedeemAmount)) {
            amountToSupply = amountToSupplyToBridgeToAchieveMatch.sub(bridgeTotalSupply);

            uint256 availableBalance = IERC20(poolAsset.asset).balanceOf(poolAsset.wrapped);
            if (availableBalance != 0) {
                supplyAsset = true;
            }
            if (availableBalance < amountToSupply) {
                amountToSupply = availableBalance;
            }
        }
        // add to totalDepositsLendable incase supply fails
        if (supplyAsset) {
            // send portion to anchor

            uint256 amountBack = IAvaToken(poolAsset.wrapped).supply(
                poolAsset.bridgeAddress,
                amountToSupply
            );
            if (amountBack != 0) {
                poolAsset.lastRebalanceTimestamp = block.timestamp;
            }
        }

        bool redeemAsset = false;
        uint256 amountToRedeem;

        if (amountToSupplyToBridgeToAchieveMatch.add(bridgeMinSupplyRedeemAmount) <= bridgeTotalSupply) {
            amountToRedeem = bridgeTotalSupply.sub(amountToSupplyToBridgeToAchieveMatch);
            redeemAsset = true;
        }
        // remove from totalDepositsLendable in case redeem fails
        // withdraw will need to come from lendable assets in tthe event of a failed redeem event
        if (redeemAsset) {
            // send portion to anchor
            bool result = IAvaToken(poolAsset.wrapped).redeem(
                poolAsset.bridgeAddress,
                amountToRedeem,
                poolAsset.wrapped
            );
            if (result) {
                poolAsset.lastRebalanceTimestamp = block.timestamp;
                // if we redeem successfully, add amount to lendable
            }
        }
        return (amountToSupply, amountToRedeem);
    } */

    function bridgeRemovalOnWithdrawSavings(
        PoolStorage.PoolAsset storage poolAsset,
        uint256 amountToWithdraw // amount account withdraw
    ) internal view returns (uint256) {
        /* console.log("rebalanceBridgeRealTime amountToWithdraw", amountToWithdraw); */

        // current valuee bridged
        // 700
        /* uint256 asdf = IAvaToken(poolAsset.wrapped).bridgeTotalScaledSupply().wadMul(poolAsset.bridgeExchangeRate); */
        /* console.log("rebalanceBridgeRealTime asdf", asdf); */
        /* console.log("rebalanceBridgeRealTime poolAsset.bridgeExchangeRate", poolAsset.bridgeExchangeRate); */

        uint256 amountBridged = IAvaToken(poolAsset.wrapped).depositsSuppliedTotalSupply();
        /* console.log("rebalanceBridgeRealTime amountBridged", amountBridged); */


        // total value
        // 1000 - 100
        // 900

        uint256 totalSupply = IERC20(poolAsset.wrapped).totalSupply(); // total amount of assets lends and brige
        /* console.log("rebalanceBridgeRealTime totalSupply", totalSupply); */

        /* if (totalSupply >= amountToWithdraw) {
            return ~uint256(0);
        } */
        require(totalSupply >= amountToWithdraw, "Error: Withdraw amount too great");

        totalSupply = totalSupply.sub(amountToWithdraw); // total minus withdraw amount
        /* console.log("rebalanceBridgeRealTime totalSupply2", totalSupply); */


        // amount required repay (lends and bridge) to match debt APR
        // 900 * .14 = 126
        uint256 amountToAchieve = totalSupply.wadMul(poolAsset.borrowInterestRate);
        /* console.log("rebalanceBridgeRealTime amountToAchieve", amountToAchieve); */

        // repay amounts
        // 0
        uint256 totalDebtReturned = IERC20(poolAsset.debtWrappedAsset).totalSupply().wadMul(poolAsset.borrowInterestRate); // suedo debt returned yr (non-compounded)
        /* console.log("rebalanceBridgeRealTime totalDebtReturned", totalDebtReturned); */
        /* console.log("rebalanceBridgeRealTime poolAsset.borrowInterestRate", poolAsset.borrowInterestRate); */

        // just in case
        if (totalDebtReturned > amountToAchieve) { return 0; }

        // difference to achieve
        // 126 - 0 = 126
        uint256 amountSpreadToAchieve = amountToAchieve.sub(totalDebtReturned);
        /* console.log("rebalanceBridgeRealTime amountSpreadToAchieve", amountSpreadToAchieve); */



        // amount needed to send to bridge to achieve difference
        /* uint256 amountToSupplyToBridgeToAchieveMatch = amountSpreadToAchieve.wadDiv(poolAsset.bridgeInterestRate);
        console.log("rebalanceBridgeRealTime amountToSupplyToBridgeToAchieveMatch", amountToSupplyToBridgeToAchieveMatch); */

        // accounting to depositors interest rate factor
        // 126 / .2 = 630
        uint256 amountToSupplyToBridgeToAchieveMatch = amountSpreadToAchieve.wadDiv(poolAsset.depositsSuppliedInterestRate);
        /* console.log("rebalanceBridgeRealTime amountToSupplyToBridgeToAchieveMatch", amountToSupplyToBridgeToAchieveMatch); */

        uint256 bridgeRemoveToUser = 0;
        if (amountBridged >= amountToSupplyToBridgeToAchieveMatch) {
            // 700 - 630 = 70
            bridgeRemoveToUser = amountBridged.sub(amountToSupplyToBridgeToAchieveMatch);
            if (bridgeRemoveToUser < poolAsset.bridgeMinSupplyRedeemAmount) {
                bridgeRemoveToUser = 0;
            }
        }
        /* console.log("rebalanceBridgeRealTime bridgeRemoveToUser", bridgeRemoveToUser); */

        // example
        // user gets ~70 from bridge and 30 from contract
        return bridgeRemoveToUser;
    }

    // total amount of assets lends and brige
    // gets the total amount of savings that should be sent to anchor
    // not accounting for any currently supplied assets

    // real time veresion.  will take only current storages
    // only call as last call
    // goal is to ensure depositor are getting the interest rate about == to borrowers inteerest rate
    /* function rebalanceBridgeRealTime(
        PoolStorage.PoolAsset storage poolAsset
    ) internal returns (uint256) {
        // total value
        uint256 totalSupply = IERC20(poolAsset.wrapped).totalSupply(); // total amount of assets lends and brige

        // amount required repay (lends and bridge) to match debt APR
        uint256 amountToAchieve = totalSupply.wadMul(poolAsset.borrowInterestRate);

        // repay amounts
        uint256 totalDebtReturned = IERC20(poolAsset.debtWrappedAsset).totalSupply().wadMul(poolAsset.borrowInterestRate); // suedo debt returned yr (non-compounded)

        // difference to achieve
        uint256 amountSpreadToAchieve = amountToAchieve.sub(totalDebtReturned);
        // amount needed to send to bridge to achieve difference

        // accounting to depositors interest rate factor
        return amountSpreadToAchieve.wadDiv(poolAsset.depositsSuppliedInterestRate);
    } */

    function bridgeSupplyOnDepositSavings(
        PoolStorage.PoolAsset storage poolAsset,
        uint256 amountAdded // 100
    ) internal returns (uint256) {
        // 700
        /* uint256 amountBridged = IAvaToken(poolAsset.wrapped).bridgeTotalScaledSupply().wadMul(poolAsset.bridgeExchangeRate); */

        uint256 amountBridged = IAvaToken(poolAsset.wrapped).depositsSuppliedTotalSupply();

        // total value
        // 1000 + 100 = 1100
        uint256 totalSupply = IERC20(poolAsset.wrapped).totalSupply().add(amountAdded); // total amount of assets lends and brige
        // amount required repay (lends and bridge) to match debt APR
        // 1100 * .14 = 154
        uint256 amountToAchieve = totalSupply.wadMul(poolAsset.borrowInterestRate);

        // repay amounts
        // 0
        uint256 totalDebtReturned = IERC20(poolAsset.debtWrappedAsset).totalSupply().wadMul(poolAsset.borrowInterestRate); // suedo debt returned yr (non-compounded)


        // just in case
        if (totalDebtReturned > amountToAchieve) { return 0; }

        // difference to achieve
         // 154 - 0 = 154
        /* uint256 amountSpreadToAchieve = amountToAchieve.sub(totalDebtReturned); */

        // amount needed to send to bridge to achieve difference

        // accounting to depositors interest rate factor
        // 154 / .2 = 770
        uint256 amountToSupplyToBridgeToAchieveMatch = (amountToAchieve.sub(totalDebtReturned)).wadDiv(poolAsset.depositsSuppliedInterestRate);
        uint256 amountBack = IBridge(poolAsset.bridgeAddress).depositAmountMinusFees(amountToSupplyToBridgeToAchieveMatch);
        uint256 feesAmount = amountToSupplyToBridgeToAchieveMatch.sub(amountBack);
        // 773.86390479824937351671708897541 = ((770 / (1-.001)) / (1-.003)) / (1-.001)
        /* uint256 amountToBridge = amountToSupplyToBridgeToAchieveMatch.wadDiv(uint256(1e18).sub(bridgeFee)).wadDiv(uint256(1e18).sub(tax)); */
        uint256 amountToBridge = amountToSupplyToBridgeToAchieveMatch.add(feesAmount);


        uint256 bridgeAmountToAdd = 0;
        if (amountToBridge > amountBridged){
            // 773.86390479824937351671708897541 - 700 = 73.86390479824937351671708897541
            bridgeAmountToAdd = amountToBridge.sub(amountBridged);

            if (bridgeAmountToAdd < poolAsset.bridgeMinSupplyRedeemAmount) {
                bridgeAmountToAdd = 0;
            }
        }


        return bridgeAmountToAdd;
    }

    function simulateDepositsSuppliedExchangeRate(
        uint256 bridgeExchangeRate,
        uint256 lastUpdatedBridgeExchangeRate,
        uint256 lastUpdatedDepositsExchangeRate,
        uint256 depositsSuppliedInterestRateFactor
    ) internal view returns (uint256) {
        if (bridgeExchangeRate <= lastUpdatedBridgeExchangeRate) { return lastUpdatedDepositsExchangeRate; }
        uint256 bridgeExchangeRateAccrued = bridgeExchangeRate.sub(lastUpdatedBridgeExchangeRate);
        uint256 rateAccrued = bridgeExchangeRateAccrued.wadDiv(lastUpdatedBridgeExchangeRate); // accrud/last*debtInterestRateFactor
        uint256 lastDepositsSuppliedExchangRate = lastUpdatedDepositsExchangeRate;
        uint256 depositsSuppliedRateAccrued = rateAccrued.wadMul(depositsSuppliedInterestRateFactor);
        return lastDepositsSuppliedExchangRate.add(lastDepositsSuppliedExchangRate.wadMul(depositsSuppliedRateAccrued));
    }


    // wrapped exchange rate is the exchange rate of bridged assets for deposits

    function accrueOverallDepositExchangeRate(
        PoolStorage.PoolAsset storage poolAsset,
        uint256 totalRepay,
        uint256 previousTotalSupply
    ) internal {
        if (totalRepay <= 0) {
            return;
        }
        uint256 lastUpdatedOverallDepositIndex = poolAsset.overallExchangeRate;

        poolAsset.overallExchangeRate = lastUpdatedOverallDepositIndex.add((lastUpdatedOverallDepositIndex.wadMul((totalRepay.wadMul(ONE_FACTOR.sub(poolAsset.reserveFactor))).wadDiv(previousTotalSupply))));
        // send 10% to reserves

        IAvaToken(poolAsset.wrapped).mintToSharedTreasury(totalRepay.wadMul(poolAsset.reserveFactor), poolAsset.overallExchangeRate);
    }

    /* function canLiquidate(
        mapping(address => PoolStorage.PoolAsset) storage poolAssets,
        mapping(uint256 => address) storage poolAssetsList,
        uint256 poolAssetsCount,
        address account
    ) internal view returns (bool, uint256, uint256) {
        // assets
        uint256 totalDebt;
        uint256 totalCollateralPrincipal;

        // params
        //uint256 avgLtv;
        uint256 avgLiquidationThreshold;

        for (uint256 i = 0; i < poolAssetsCount; i++) {
            address currentPoolAssetAddress = poolAssetsList[i];
            PoolStorage.PoolAsset storage currentPoolAsset = poolAssets[currentPoolAssetAddress];

            uint256 assetDecimals = currentPoolAsset.decimals;
            uint256 assetPrice = uint256(IPriceConsumerV3(priceOracle).getLatestPrice(currentPoolAsset.asset));
            uint8 priceDecimals = IPriceConsumerV3(priceOracle).decimals(currentPoolAsset.asset);

            // assets
            uint256 debt;
            uint256 debtPrincipal;
            if (currentPoolAsset.isSavings){
                debt = IERC20(currentPoolAsset.debtWrappedAsset).balanceOf(account);
                debtPrincipal = IDebtToken(currentPoolAsset.debtWrappedAsset).balanceOfPrincipal(account);
            }
            uint256 collateralPrincipal;
            if (currentPoolAsset.isCollateral){
                collateralPrincipal = ICollateralToken(currentPoolAsset.collateralAssetWrapped).effectivePrincipal(account);
            }

            if (debt == 0 && collateralPrincipal == 0) {
                continue;
            }
            if (currentPoolAsset.decimals != uint256(18)) {
                uint256 decimalsLess = uint256(18).sub(currentPoolAsset.decimals);
                debt = debt*(10**decimalsLess);
                debtPrincipal = debtPrincipal*(10**decimalsLess);
                collateralPrincipal = collateralPrincipal*(10**decimalsLess);
                totalDebt += debt;
                totalCollateralPrincipal += collateralPrincipal;
            } else {
                totalDebt += debt;
                totalCollateralPrincipal += collateralPrincipal;
            }
            // params
            // using debt principal
            uint256 liquidationThreshold = currentPoolAsset.liquidationThreshold;

            avgLiquidationThreshold = avgLiquidationThreshold.add(
                debtPrincipal.mul(liquidationThreshold)
            );

            // =======
            // params
            // using collateral principal
            //uint256 liquidationThreshold = currentPoolAsset.liquidationThreshold;

            //avgLiquidationThreshold = avgLiquidationThreshold.add(
            //    collateralPrincipal.mul(liquidationThreshold)
            //);
        }
        if (totalDebt == 0) {
            return (false, 0, 0);
        }
        console.log("avgLiquidationThreshold1", avgLiquidationThreshold);

        avgLiquidationThreshold = avgLiquidationThreshold.div(totalCollateralPrincipal);
        console.log("avgLiquidationThreshold2", avgLiquidationThreshold);

        bool canLiquidate = calculateHealth(
            totalCollateralPrincipal,
            totalDebt,
            avgLiquidationThreshold
        );

        uint256 currentLtv;
        if (totalDebt != 0) {
            currentLtv = totalDebt.wadDiv(totalCollateralPrincipal);
        }


        return (canLiquidate, avgLiquidationThreshold, currentLtv);

    } */

    struct canLiquidateParams {
        address account;
        uint256 totalDebt;
        uint256 totalCollateral;
    }

    function calculateHealth(
        uint256 totalCollateral,
        uint256 totalDebt,
        uint256 avgLiquidationThreshold
    ) internal view returns (bool) {
        if (totalDebt == 0) return false;
        return ((totalDebt.wadMul(avgLiquidationThreshold)).wadDiv(totalDebt) <= 1e18);
        /* return ((totalCollateralPrincipal.wadMul(avgLiquidationThreshold)).wadDiv(totalDebt) <= 1e18); */
    }

    /* function canLiquidate(
        mapping(address => PoolStorage.PoolAsset) storage poolAssets,
        mapping(uint256 => address) storage poolAssetsList,
        uint256 poolAssetsCount,
        address account,
        address priceOracle
    ) internal view returns (bool, uint256, uint256) {
        canLiquidateParams memory params;
        params.account = account;
        // assets

        // params
        uint256 avgLiquidationThreshold;

        for (uint256 i = 0; i < poolAssetsCount; i++) {
            address currentPoolAssetAddress = poolAssetsList[i];
            PoolStorage.PoolAsset storage currentPoolAsset = poolAssets[currentPoolAssetAddress];

            uint256 assetPrice = uint256(IPriceConsumerV3(priceOracle).getLatestPrice(currentPoolAssetAddress));
            uint8 priceDecimals = IPriceConsumerV3(priceOracle).decimals(currentPoolAssetAddress);

            // assets
            uint256 debt;
            uint256 debtPrincipal;
            if (currentPoolAsset.isSavings){
                debt = IERC20(currentPoolAsset.debtWrappedAsset).balanceOf(params.account).mul(uint256(assetPrice)).div(10**uint256(priceDecimals));
                debtPrincipal = IDebtToken(currentPoolAsset.debtWrappedAsset).balanceOfPrincipal(params.account).mul(uint256(assetPrice)).div(10**uint256(priceDecimals));
                console.log("canLiquidate debtPrincipal", debtPrincipal);
            }
            uint256 collateralPrincipal;
            if (currentPoolAsset.isCollateral){
                collateralPrincipal = ICollateralToken(currentPoolAsset.collateralAssetWrapped).effectivePrincipal(params.account).mul(uint256(assetPrice)).div(10**uint256(priceDecimals));
                console.log("canLiquidate collateralPrincipal", collateralPrincipal);

            }

            if (debt == 0 && collateralPrincipal == 0) {
                continue;
            }
            if (currentPoolAsset.decimals != uint256(18)) {
                uint256 decimalsLess = uint256(18).sub(currentPoolAsset.decimals);
                debt = debt*(10**decimalsLess);
                debtPrincipal = debtPrincipal*(10**decimalsLess);
                collateralPrincipal = collateralPrincipal*(10**decimalsLess);
                params.totalDebt += debt;
                params.totalDebtPrincipal += debtPrincipal;
                params.totalCollateralPrincipal += collateralPrincipal;
            } else {
                params.totalDebt += debt;
                params.totalDebtPrincipal += debtPrincipal;
                params.totalCollateralPrincipal += collateralPrincipal;
            }
            // params
            uint256 liquidationThreshold = currentPoolAsset.liquidationThreshold;
            console.log("canLiquidate liquidationThreshold", liquidationThreshold);
            console.log("canLiquidate debtPrincipal", debtPrincipal);

            avgLiquidationThreshold = avgLiquidationThreshold.add(
                debtPrincipal.mul(liquidationThreshold)
            );
            console.log("canLiquidate avgLiquidationThreshold", avgLiquidationThreshold);

        }
        if (params.totalDebt == 0) {
            return (false, 0, 0);
        }

        // use totalDebt to get liquidation threshold
        avgLiquidationThreshold = avgLiquidationThreshold.div(params.totalDebtPrincipal);

        bool canLiquidate = calculateHealth(
            params.totalCollateralPrincipal,
            params.totalDebt,
            avgLiquidationThreshold
        );

        uint256 currentLtv;
        if (params.totalDebt != 0) {
            currentLtv = params.totalDebt.wadDiv(params.totalCollateralPrincipal);
        }


        return (canLiquidate, avgLiquidationThreshold, currentLtv);

    } */

    struct liquidationDataParams {
        address account;
        address debtAssetAddress;
        uint256 amount;
        uint256 debtAssetPrice;
        uint256 collateralAssetPrice;
        uint256 debtRepay;
        uint256 debtRepayRatio;
        address collateralAssetWrapped;
        uint256 debt;
        uint256 liquidationBonusFactor;
        uint256 debtAssetDecimals;
        uint256 collateralAssetDecimals;
        uint256 startTimestamp;
        uint256 collateralDebtDelta;
        uint256 collateralBonusAmount;
        uint256 collateralFromDebtRepayAmount;
        uint256 collateralBonusToReceiver;
        uint256 debtBalance;
    }

    // single asset liquidation
    /* function liquidationData(
        PoolStorage.PoolAsset storage collateralAsset,
        PoolStorage.PoolAsset storage debtAsset,
        PoolStorage.UserData storage userData,
        address account,
        uint256 amount,
        address priceOracle
    ) internal view returns (uint256, uint256) {
        liquidationDataParams memory params;
        params.account = account;
        params.debtAssetDecimals = debtAsset.decimals;

        // converting all to 18 decimals to not loose accuracy

        // 120
        // 130 @ 100%
        params.amount = amount.mul(10**18).div(params.debtAssetDecimals);

        params.debtAssetAddress = debtAsset.asset;
        params.debtBalance = IERC20(debtAsset.debtWrappedAsset).balanceOf(params.account).mul(10**18).div(params.debtAssetDecimals);

        if (params.amount > params.debtBalance) {
            params.amount = params.debtBalance;
        }

        // 0.92307692307692307692307692307692 = 120/130
        // 1.0 = 130/130 @ 100%
        params.debtRepayRatio = params.amount.wadDiv(params.debtBalance);


        params.debtAssetPrice = uint256(IPriceConsumerV3(priceOracle).getLatestPrice(params.debtAssetAddress));
        uint8 debtAssetPriceDecimals = IPriceConsumerV3(priceOracle).decimals(params.debtAssetAddress);

        // 133.9 = 130 * 1.03
        params.debt = params.debtBalance.mul(params.debtAssetPrice).div(10**uint256(debtAssetPriceDecimals));

        // 123.6 = 120 * 1.03
        // 133.9 = 130 * 1.03 @ 100%
        params.debtRepay = params.amount.mul(params.debtAssetPrice).div(10**uint256(debtAssetPriceDecimals));

        address collateralAssetAddress = collateralAsset.asset;
        params.collateralAssetPrice = uint256(IPriceConsumerV3(priceOracle).getLatestPrice(collateralAssetAddress));

        uint8 collateralAssetPriceDecimals = IPriceConsumerV3(priceOracle).decimals(collateralAssetAddress);

        // 118.84615384615384615384615384615 = 1.03 * 120 / 1.04
        // 133.9 = 1.03 * 130 @ 100%
        uint256 collateralFromDebtAmount = params.debt.div(params.collateralAssetPrice.div(10**uint256(collateralAssetPriceDecimals)));

        params.collateralAssetDecimals = collateralAsset.decimals;

        params.collateralAssetWrapped = collateralAsset.collateralAssetWrapped;
        uint256 collateralBalance = IERC20(params.collateralAssetWrapped).balanceOf(params.account).mul(10**18).div(params.collateralAssetDecimals);

        // 145.6 = 1.04 * 140
        uint256 collateral = collateralBalance.mul(params.collateralAssetPrice).div(10**uint256(collateralAssetPriceDecimals));

        // available value to be bonusable not inluding max factor
        // 11.7 = 145.6 - 133.9
        params.collateralDebtDelta = collateral.sub(params.debt);

        address debtWrappedAddress = debtAsset.debtWrappedAsset;

        address collateralAssetAddress = collateralAsset.asset;
        params.collateralAssetDecimals = collateralAsset.decimals;

        params.collateralAssetWrapped = collateralAsset.collateralAssetWrapped;
        params.liquidationBonusFactor = collateralAsset.liquidationBonusFactor;

        uint256 fullLiquidationTimeframe = debtAsset.fullLiquidationTimeframe;
        params.startTimestamp = userData.startTimestamp;
         // needd
        (
            uint256 debtRepay,
            uint256 collateralAssetPrice,
            uint8 collateralAssetPriceDecimals,
            uint256 amount,
            uint256 debtBalance,
            uint256 collateralBonusAmount
        ) = getLiquidationParameters(
            liquidationDataParams memory params
        );

        // liquidationBonusFactor = .8
        // .80
        // 118.84615384615384615384615384615 = 1.03 * 120 / 1.04
        // 128.75 = 1.03 * 130 / 1.04 @ 100%
        params.collateralFromDebtRepayAmount = params.debtRepay.div(params.collateralAssetPrice.div(10**uint256(collateralAssetPriceDecimals)));
        // @ liquidationBonusFactor
        // 8.64 = 9.36 * 0.92307692307692307692307692307692
        // 9.36 = 9.36 * 1.0 @ 100%
        // @ full
        // 10.8 = 11.7 * 0.92307692307692307692307692307692
        // 11.7 = 11.7 * 1.0 @ 100%
        params.collateralBonusToReceiver = params.collateralBonusAmount.wadMul(params.amount.wadDiv(params.debtBalance));

        // total collateral value to user is
        // 127.15384615384615384615384615384 = 118.84615384615384615384615384615 + 8.64 / 1.04
        // 137.75 = 128.75 + 9.36 / 1.04 @ 100%
        // @ full
        // 129.23076923076923076923076923077 = 118.84615384615384615384615384615 + 10.8 / 1.04
        // 140 = 128.75 + 11.7 / 1.04 @ 100%
        uint256 receiverAmount = params.collateralFromDebtRepayAmount.add(params.collateralBonusToReceiver)
          .div(params.collateralAssetPrice)
          .mul(10**uint256(collateralAssetPriceDecimals)).mul(params.collateralAssetDecimals).div(10**18);

        return (params.amount, receiverAmount);
    } */

    struct liquidationParametersParams {
        address account;
        uint256 amount;
        uint256 debtAssetPrice;
        uint256 collateralAssetPrice;
        uint256 debtRepay;
        uint256 debtRepayRatio;
        uint256 debt;
        uint256 debtBalance;
        uint256 collateralDebtDelta;
        uint256 collateralBonusAmount;
    }


    /* function getLiquidationParameters(
        PoolStorage.PoolAsset storage collateralAsset,
        PoolStorage.PoolAsset storage debtAsset,
        uint256 startTimestamp,
        address account,
        uint256 amount,
        address priceOracle
    ) internal view returns (
        uint256,
        uint256,
        uint8,
        uint256,
        uint256,
        uint256
    ) {
        liquidationParametersParams memory params;
        params.account = account;

        // converting all to 18 decimals to not loose accuracy

        // 120
        // 130 @ 100%
        params.amount = amount.mul(10**18).div(debtAsset.decimals);

        params.debtBalance = IERC20(debtAsset.debtWrappedAddress).balanceOf(params.account).mul(10**18).div(debtAsset.decimals);

        if (params.amount > params.debtBalance) {
            params.amount = params.debtBalance;
        }

        // 0.92307692307692307692307692307692 = 120/130
        // 1.0 = 130/130 @ 100%
        params.debtRepayRatio = params.amount.wadDiv(params.debtBalance);


        params.debtAssetPrice = uint256(IPriceConsumerV3(priceOracle).getLatestPrice(debtAsset.asset));
        uint8 debtAssetPriceDecimals = IPriceConsumerV3(priceOracle).decimals(debtAsset.asset);

        // 133.9 = 130 * 1.03
        params.debt = params.debtBalance.mul(params.debtAssetPrice).div(10**uint256(debtAssetPriceDecimals));

        // 123.6 = 120 * 1.03
        // 133.9 = 130 * 1.03 @ 100%
        params.debtRepay = params.amount.mul(params.debtAssetPrice).div(10**uint256(debtAssetPriceDecimals));

        params.collateralAssetPrice = uint256(IPriceConsumerV3(priceOracle).getLatestPrice(collateralAsset.collateralAssetAddress));

        uint8 collateralAssetPriceDecimals = IPriceConsumerV3(priceOracle).decimals(collateralAsset.collateralAssetAddress);

        // 118.84615384615384615384615384615 = 1.03 * 120 / 1.04
        // 133.9 = 1.03 * 130 @ 100%
        uint256 collateralFromDebtAmount = params.debt.div(params.collateralAssetPrice.div(10**uint256(collateralAssetPriceDecimals)));

        uint256 collateralBalance = IERC20(collateralAsset.collateralAssetWrapped).balanceOf(params.account).mul(10**18).div(collateralAsset.collateralAssetDecimals);

        // 145.6 = 1.04 * 140
        uint256 collateral = collateralBalance.mul(params.collateralAssetPrice).div(10**uint256(collateralAssetPriceDecimals));

        // available value to be bonusable not inluding max factor
        // 11.7 = 145.6 - 133.9
        params.collateralDebtDelta = collateral.sub(params.debt);


        // liquidationBonusFactor = .8
        // .80
        // available bonus conditional 1
        // 9.36 = 11.7 * .80
        params.collateralBonusAmount = params.collateralDebtDelta.wadMul(collateralAsset.liquidationBonusFactor);

        // available bonus conditional 2
        uint256 timeRequired = block.timestamp.sub(startTimestamp);
        if (timeRequired > debtAsset.fullLiquidationTimeframe) {
            // 11.7 = 11.7 * 1.0
            params.collateralBonusAmount = params.collateralDebtDelta;
        }

        return (
            params.debtRepay,
            params.collateralAssetPrice,
            collateralAssetPriceDecimals,
            params.amount,
            params.debtBalance,
            params.collateralBonusAmount
        );
    } */

/*
    function getLiquidationParameters(
        address collateralAssetAddress,
        uint256 collateralAssetDecimals,
        address collateralAssetWrapped,
        uint256 liquidationBonusFactor,
        uint256 debtAssetDecimals,
        address debtAssetAddress,
        address debtWrappedAddress,
        uint256 fullLiquidationTimeframe,
        uint256 startTimestamp,
        address account,
        uint256 amount,
        address priceOracle
    ) internal view returns (
        uint256,
        uint256,
        uint8,
        uint256,
        uint256,
        uint256
    ) {
        liquidationParametersParams memory params;
        params.account = account;

        // converting all to 18 decimals to not loose accuracy

        // 120
        // 130 @ 100%
        params.amount = amount.mul(10**18).div(debtAssetDecimals);

        params.debtBalance = IERC20(debtWrappedAddress).balanceOf(params.account).mul(10**18).div(debtAssetDecimals);

        if (params.amount > params.debtBalance) {
            params.amount = params.debtBalance;
        }

        // 0.92307692307692307692307692307692 = 120/130
        // 1.0 = 130/130 @ 100%
        params.debtRepayRatio = params.amount.wadDiv(params.debtBalance);


        params.debtAssetPrice = uint256(IPriceConsumerV3(priceOracle).getLatestPrice(debtAssetAddress));
        uint8 debtAssetPriceDecimals = IPriceConsumerV3(priceOracle).decimals(debtAssetAddress);

        // 133.9 = 130 * 1.03
        params.debt = params.debtBalance.mul(params.debtAssetPrice).div(10**uint256(debtAssetPriceDecimals));

        // 123.6 = 120 * 1.03
        // 133.9 = 130 * 1.03 @ 100%
        params.debtRepay = params.amount.mul(params.debtAssetPrice).div(10**uint256(debtAssetPriceDecimals));

        params.collateralAssetPrice = uint256(IPriceConsumerV3(priceOracle).getLatestPrice(collateralAssetAddress));

        uint8 collateralAssetPriceDecimals = IPriceConsumerV3(priceOracle).decimals(collateralAssetAddress);

        // 118.84615384615384615384615384615 = 1.03 * 120 / 1.04
        // 133.9 = 1.03 * 130 @ 100%
        uint256 collateralFromDebtAmount = params.debt.div(params.collateralAssetPrice.div(10**uint256(collateralAssetPriceDecimals)));

        uint256 collateralBalance = IERC20(collateralAssetWrapped).balanceOf(params.account).mul(10**18).div(collateralAssetDecimals);

        // 145.6 = 1.04 * 140
        uint256 collateral = collateralBalance.mul(params.collateralAssetPrice).div(10**uint256(collateralAssetPriceDecimals));

        // available value to be bonusable not inluding max factor
        // 11.7 = 145.6 - 133.9
        params.collateralDebtDelta = collateral.sub(params.debt);


        // liquidationBonusFactor = .8
        // .80
        // available bonus conditional 1
        // 9.36 = 11.7 * .80
        params.collateralBonusAmount = params.collateralDebtDelta.wadMul(liquidationBonusFactor);

        // available bonus conditional 2
        uint256 timeRequired = block.timestamp.sub(startTimestamp);
        if (timeRequired > fullLiquidationTimeframe) {
            // 11.7 = 11.7 * 1.0
            params.collateralBonusAmount = params.collateralDebtDelta;
        }

        return (
            params.debtRepay,
            params.collateralAssetPrice,
            collateralAssetPriceDecimals,
            params.amount,
            params.debtBalance,
            params.collateralBonusAmount
        );
    } */

    /* function liquidationData(
        PoolStorage.PoolAsset storage collateralAsset,
        PoolStorage.PoolAsset storage debtAsset,
        PoolStorage.UserData storage userData,
        address account,
        uint256 amount,
        address priceOracle
    ) internal view returns (uint256, uint256) {
        liquidationDataParams memory params;
        params.account = account;
        params.debtAssetDecimals = debtAsset.decimals;

        params.amount = amount.mul(10**18).div(params.debtAssetDecimals);

        // debt
        params.debtAssetAddress = debtAsset.asset;
        uint256 debtBalance = IERC20(debtAsset.debtWrappedAsset).balanceOf(params.account).mul(10**18).div(params.debtAssetDecimals);
        console.log("liquidationData debtBalance", debtBalance);

        if (params.amount > debtBalance) {
            params.amount = debtBalance;
        }

        // debt value
        params.debtAssetPrice = uint256(IPriceConsumerV3(priceOracle).getLatestPrice(params.debtAssetAddress));
        uint8 debtAssetPriceDecimals = IPriceConsumerV3(priceOracle).decimals(params.debtAssetAddress);

        // 1000 = 1000 * 1
        // value of repay
        params.debtRepay = params.amount.mul(params.debtAssetPrice).div(10**uint256(debtAssetPriceDecimals));

        // 1200 = 1200 * 1
        params.debt = debtBalance.mul(params.debtAssetPrice).div(10**uint256(debtAssetPriceDecimals));

        // .80 = 1000/1200
        params.debtRepayRatio = params.debtRepay.wadDiv(params.debt);

        // collateral

        // collateral value
        address collateralAssetAddress = collateralAsset.asset;
        params.collateralAssetPrice = uint256(IPriceConsumerV3(priceOracle).getLatestPrice(collateralAssetAddress));

        uint8 collateralAssetPriceDecimals = IPriceConsumerV3(priceOracle).decimals(collateralAssetAddress);

        // value of debt in collateral asset
        uint256 collateralFromDebtAmount = params.debt.div(params.collateralAssetPrice.div(10**uint256(collateralAssetPriceDecimals)));

        params.collateralAssetDecimals = collateralAsset.decimals;

        // 1400 = 1400 * 1
        params.collateralAssetWrapped = collateralAsset.collateralAssetWrapped;
        uint256 collateralBalance = IERC20(params.collateralAssetWrapped).balanceOf(params.account).mul(10**18).div(params.collateralAssetDecimals);


        console.log("liquidationData collateralBalance", collateralBalance);

        uint256 collateral = collateralBalance.mul(params.collateralAssetPrice).div(10**uint256(collateralAssetPriceDecimals));

        // compare
        // 200 = 1400 - 1200
        params.debtAssetDecimals = debtAsset.decimals;
        params.collateralAssetDecimals = collateralAsset.decimals;
        uint256 collateralDebtDelta = collateral.sub(params.debt.mul(10**params.debtAssetDecimals).div(10**params.collateralAssetDecimals));

        // liquidationBonusFactor = .8
        // 160 = 200 * .80.
        params.liquidationBonusFactor = collateralAsset.liquidationBonusFactor;
        uint256 collateralBonusAmount = collateralDebtDelta.wadMul(params.liquidationBonusFactor);

        params.startTimestamp = userData.startTimestamp;
        uint256 timeRequired = block.timestamp.sub(params.startTimestamp);
        if (timeRequired > debtAsset.fullLiquidationTimeframe) {
            collateralBonusAmount = collateralDebtDelta;
        }

        // 1120 = 1400 * .80
        uint256 collateralToReceiver = collateral.wadMul(params.debtRepayRatio);
        // 128 = 160 * .80
        uint256 collateralToReceiverRepayBonus = collateralBonusAmount.wadMul(params.debtRepayRatio);
        // total collateral value to user is 1248 = 1120 + 128
        uint256 receiverAmount = (collateralToReceiver.add(collateralToReceiverRepayBonus)).div(params.collateralAssetPrice).mul(10**uint256(collateralAssetPriceDecimals));

        return (params.amount, receiverAmount);
    } */



    /* function getUserAssetDebtAndCollateral(
        address user,
        address debtWrappedAsset,
        address collateralWrappedAsset
    ) internal view returns (uint256, uint256) {
        uint256 borrowerDebt = IERC20(debtWrappedAsset).balanceOf(user);
        uint256 borrowerCollateral = IERC20(collateralWrappedAsset).balanceOf(user);
        return (borrowerDebt, borrowerCollateral);
    } */

    function getAssetSavingsInterestRate(
        address wrapped,
        uint256 lendRate,
        uint256 savingsBridgeRate,
        uint256 totalDebt,
        uint256 lendTotalSupply,
        uint256 savingsBridgeTotalSupply
    ) internal view returns (uint256) {
        uint256 lendInterestReturn;
        if (totalDebt != 0) {
            lendInterestReturn = totalDebt.wadMul(lendRate);
        }
        uint256 totalSupplySimulated = lendTotalSupply.add(savingsBridgeTotalSupply);
        // weighted avgs
        uint256 savingsBridgeInterestReturn = savingsBridgeTotalSupply.wadMul(savingsBridgeRate);
        uint256 totalInterestReturn = lendInterestReturn.add(savingsBridgeInterestReturn);
        if (totalInterestReturn == 0 || totalSupplySimulated == 0) { return 0; }
        return totalInterestReturn.wadDiv(totalSupplySimulated);
    }

    function validateLiquidationCall(
        PoolStorage.PoolAsset storage collateralAsset,
        PoolStorage.PoolAsset storage debtAsset,
        PoolStorage.UserData storage userData,
        address borrower
    ) internal view {
        console.log("validateLiquidationCall userData.startTimestamp", userData.startTimestamp);
        console.log("validateLiquidationCall debtAsset.maxDebtTimeframe", debtAsset.maxDebtTimeframe);
        console.log("validateLiquidationCall block.timestamp.sub(userData.startTimestamp)", block.timestamp.sub(userData.startTimestamp));

        require(block.timestamp.sub(userData.startTimestamp) > debtAsset.maxDebtTimeframe, "Error: Max debt timeframe not yet breached");
        require(collateralAsset.on && debtAsset.on, "Error: One or both assets paused.");
        uint256 borrowerDebt = IERC20(debtAsset.debtWrappedAsset).balanceOf(borrower);
        require(borrowerDebt != 0, "Error: Borrower has no debt.");
    }

    function validateDepositCollateralAndBorrow(
        PoolStorage.PoolAsset storage collateralAsset,
        PoolStorage.PoolAsset storage debtAsset,
        address priceOracle,
        uint256 collateralAmount,
        PoolStorage.UserData storage userData,
        uint256 borrowAmount
    ) internal view {
        require(!userData.borrowing, "Error: Position open, try using another wallet address");
        require(collateralAsset.isCollateral && debtAsset.isSavings, "Error: Collateral is not collateral asset or Debt asset is not debt asset.");
        // bridge will revert if not enough
        /* require(collateralAmount >= collateralAsset.bridgeMinSupplyRedeemAmount, "Error: Not enough liquidity."); */
        uint256 availableAmount = IERC20(debtAsset.asset).balanceOf(debtAsset.wrapped);
        borrowAmount = getValueMatchAmount(
            priceOracle,
            borrowAmount,
            collateralAsset.decimals,
            debtAsset
        );
        require(availableAmount >= borrowAmount, "Error: Not enough liquidity.");
        /* require(debtAsset.isSavings, "Error: Debt asset is not debt asset."); */


        // get user health
    }

    function validateDepositSavings(
        PoolStorage.PoolAsset storage poolAsset
    ) internal view {
        require(poolAsset.isSavings && poolAsset.on, "Error: Not savings asset.");

        // bridge will revert is amount too low
        /* require(poolAsset.on, "Error: This asset is currently off."); */
    }

    /* function getBonusAmount(
        PoolStorage.PoolAsset storage collateralAsset,
        address account,
        uint256 bonusFactor
    ) internal view returns (uint256) {
        if (bonusFactor == 0) {
            return 0;
        }

        if (bonusFactor > collateralAsset.maxCollateralBonusFactor) {
            bonusFactor = collateralAsset.maxCollateralBonusFactor;
        }
        uint256 collateralExchangeRate = collateralAsset.collateralExchangeRate;
        uint256 collateralPrincipal = ICollateralToken(collateralAsset.collateralAssetWrapped).effectivePrincipalScaled(account).wadMul(collateralExchangeRate);
        uint256 collateralValue = ICollateralToken(collateralAsset.collateralAssetWrapped).balanceOfScaled(account).wadMul(collateralExchangeRate);
        return collateralValue.sub(collateralValue).wadMul(bonusFactor);
    } */

    function confirmRepayAmount(
        address debtWrappedAsset,
        uint256 amount
    ) internal view returns (uint256, uint256) {
        uint256 debt = IERC20(debtWrappedAsset).balanceOf(msg.sender);

        uint256 repayAmount = amount;
        // if amount sent > asset debt owed, update to owed
        if (amount > debt) {
            repayAmount = debt;
        } else if (debt > amount) {
            revert("Error: Amount must be equail or greater than debt owed");
        }
        return (debt, repayAmount);
    }


    function validateRepay(
        PoolStorage.PoolAsset storage debtAsset,
        PoolStorage.PoolAsset storage collateralAsset,
        PoolStorage.UserData storage userData,
        uint256 repayAmount,
        uint256 debt
    ) internal view {
        if (debt != 0) {
            require(repayAmount > 0 && debt > 0, "Error: Repay is zero or debt is zero.");
            console.log("validateRepay", block.timestamp.sub(userData.startTimestamp));
            console.log("validateRepay", debtAsset.minDebtTimeframe);

            require(block.timestamp.sub(userData.startTimestamp) > debtAsset.minDebtTimeframe, "Error: Min debt timeframe not yet breached");
        } else {
            // if user fully liquidated, repay in should be 0
            require(repayAmount == 0 && debt == 0, "Error: Repay and debt must be zero.");
        }

        require(
          collateralAsset.on &&
          debtAsset.on &&
          debtAsset.isSavings &&
          collateralAsset.isCollateral,
          "Error: Pool currently not active."
        );
    }

    function validateWithdrawSavings(
        PoolStorage.PoolAsset storage poolAsset,
        address account,
        uint256 amount,
        uint256 redeemToAccountAmount
        /* bool emergency */
    ) internal view {
        console.log("validateWithdrawSavings amount", amount);
        console.log("validateWithdrawSavings redeemToAccountAmount", redeemToAccountAmount);
        console.log("validateWithdrawSavings IERC20(poolAsset.asset).balanceOf(poolAsset.wrapped)", IERC20(poolAsset.asset).balanceOf(poolAsset.wrapped));

        require(IERC20(poolAsset.wrapped).balanceOf(account) >= amount, "Error: Amount is higher than balance.");
        /* require(redeemToAccountAmount < ~uint256(0), "Error: Not enough liquidity, try lowering withdraw total."); */
        require(amount.sub(redeemToAccountAmount) <= IERC20(poolAsset.asset).balanceOf(poolAsset.wrapped), "Error: Not enough liquidity, try lowering withdraw total.");
        require(poolAsset.isSavings && poolAsset.on, "Error: Pool currently not active.");
    }

    // returns a users total debt in the decimals of the
    // calling pool asset
    /* function getUserTotalDebt(
        mapping(address => PoolStorage.PoolAsset) storage poolAssets,
        mapping(uint256 => address) storage savingsAssetsList,
        uint256 savingsAssetsCount,
        address account,
        uint256 currentDebtAssetDecimals
    ) internal view returns (uint256) {
        uint256 totalDebt;
        for (uint256 i = 0; i < savingsAssetsCount; i++) {
            address currentPoolAssetAddress = savingsAssetsList[i];
            PoolStorage.PoolAsset storage currentPoolAsset = poolAssets[currentPoolAssetAddress];
            uint256 balance = IERC20(currentPoolAsset.debtWrappedAsset).balanceOf(account);
            totalDebt += balance.div(10**currentPoolAsset.decimals).mul(10**currentDebtAssetDecimals);
        }
        return totalDebt;
    } */

    function getUserTotalDebt(
        mapping(address => PoolStorage.PoolAsset) storage poolAssets,
        mapping(uint256 => address) storage savingsAssetsList,
        uint256 savingsAssetsCount,
        address account,
        uint256 currentDebtAssetDecimals
    ) internal view returns (uint256) {
        uint256 totalDebt;
        for (uint256 i = 0; i < savingsAssetsCount; i++) {
            address currentPoolAssetAddress = savingsAssetsList[i];
            PoolStorage.PoolAsset storage currentPoolAsset = poolAssets[currentPoolAssetAddress];
            uint256 balance = IERC20(currentPoolAsset.debtWrappedAsset).balanceOf(account);
            totalDebt += balance.div(10**currentPoolAsset.decimals).mul(10**currentDebtAssetDecimals);
        }
        return totalDebt;
    }


    // return in 18 ddeimals
    function getUserTotalDeposits(
        mapping(address => PoolStorage.PoolAsset) storage poolAssets,
        mapping(uint256 => address) storage savingsAssetsList,
        uint256 savingsAssetsCount,
        address account
    ) internal view returns (uint256) {
        uint256 totalSavings;
        for (uint256 i = 0; i < savingsAssetsCount; i++) {
            address currentPoolAssetAddress = savingsAssetsList[i];
            PoolStorage.PoolAsset storage currentPoolAsset = poolAssets[currentPoolAssetAddress];
            uint256 balance = IERC20(currentPoolAsset.wrapped).balanceOf(account);
            if (currentPoolAsset.decimals != uint256(18)) {
                totalSavings += balance.mul(10**18).div(10**currentPoolAsset.decimals);
            } else {
                totalSavings += balance;
            }
        }
        return totalSavings;
    }

    function getValueMatchAmount(
        address priceOracle,
        uint256 fromAmount,
        uint256 fromAssetDecimals,
        PoolStorage.PoolAsset storage poolAsset
    ) internal view returns (uint256) {
        uint256 toAssetDecimals = poolAsset.decimals;

        uint256 toAssetPrice = uint256(IPriceConsumerV3(priceOracle).getLatestPrice(poolAsset.asset));

        uint8 priceDecimals = IPriceConsumerV3(priceOracle).decimals(poolAsset.asset);

        uint256 _amount = fromAmount;
        if (toAssetDecimals != fromAssetDecimals) {
            if (toAssetDecimals > fromAssetDecimals) {
                uint256 difference = toAssetDecimals.sub(fromAssetDecimals);
                _amount = fromAmount.mul(10**difference);
            } else {
                uint256 difference = fromAssetDecimals.sub(toAssetDecimals);
                _amount = fromAmount.div(10**difference);
            }
        }
        return _amount.mul(uint256(toAssetPrice)).div(10**uint256(priceDecimals));
    }

}
